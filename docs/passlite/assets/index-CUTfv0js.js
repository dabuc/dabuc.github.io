(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))s(e);new MutationObserver(e=>{for(const n of e)if(n.type==="childList")for(const c of n.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function o(e){const n={};return e.integrity&&(n.integrity=e.integrity),e.referrerPolicy&&(n.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?n.credentials="include":e.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(e){if(e.ep)return;e.ep=!0;const n=o(e);fetch(e.href,n)}})();const b={lower:"abcdefghijklmnopqrstuvwxyz",upper:"ABCDEFGHIJKLMNOPQRSTUVWXYZ",digits:"0123456789"},E={modern:"!#$%&()*+,-./:;=?@[]^_{}~",basic:"!@#$%^&*()"};function B(t){let r=t.characterSets.map(o=>b[o]).join("");return t.symbolType!=="none"&&(r+=E[t.symbolType]),r}function T(t){const o=1e5+t;return Math.min(o,1e6)}async function S(t,r,o,s,e){let n=`${t}|${r}|${s}|${e}`;const c=new TextEncoder,a=await crypto.subtle.digest("SHA-256",c.encode(n)),l=new Uint8Array(a),u=Math.ceil(s*2.8)+96,i=await crypto.subtle.importKey("raw",o,{name:"PBKDF2"},!1,["deriveBits"]),d=T(e),h=await crypto.subtle.deriveBits({name:"PBKDF2",salt:l,iterations:d,hash:"SHA-256"},i,u*8);return new Uint8Array(h)}function p(t,r,o){const s=256-256%t.length;for(let e=0;e<r.length;e++){if(o[e])continue;const n=r[e];if(n<s){o[e]=!0;const c=n%t.length;return t[c]}}throw new Error("Not enough usable bytes in pool")}function v(t,r,o,s){const e=256-256%r.length,n=[];let c=0;for(;n.length<t&&c<o.length;){if(s[c]){c++;continue}const a=o[c];if(a<e){const l=a%r.length;n.push(r[l]),s[c]=!0}c++}if(n.length<t){const a=s.filter(l=>l).length;throw new Error(`无法生成足够的字符。需要 ${t} 个，但只生成了 ${n.length} 个。（随机池大小: ${o.length}, 已用字节: ${a}）`)}return n}function A(t,r){const o=[...t];let s=r.length-1;for(let e=o.length-1;e>0;e--){const n=e+1,c=256-256%n;let a;for(;;){if(s<0)throw new Error("Not enough bytes for secure shuffle");if(a=r[s],s--,a<c){const l=a%n;[o[e],o[l]]=[o[l],o[e]];break}}}return o}function C(t,r,o){const s=B(r),e=new Array(t.length).fill(!1),n=[];if(r.symbolType!=="none"){const i=E[r.symbolType],d=p(i,t,e);n.push(d)}for(const i of r.characterSets){const d=b[i],h=p(d,t,e);n.push(h)}const c=o-n.length,a=v(c,s,t,e),l=[...n,...a];return A(l,t)}function x(t,r,o){if(o<1)throw new Error("counter 必须大于等于 1");const s=t.characterSets.length+(t.symbolType!=="none"?1:0);if(s===0)throw new Error("必须至少选择一种字符类型");if(r<s)throw new Error(`密码长度至少需要 ${s} 个字符`);if(new Set(t.characterSets).size!==t.characterSets.length)throw new Error("基础字符集有重复");const e=128;if(r>e)throw new Error(`密码长度不能超过 ${e} 个字符`)}async function N(t,r,o,s,e,n){x(n,s,e);const a=new TextEncoder().encode(o);let l=null;try{return l=await S(t,r,a,s,e),C(l,n,s).join("")}finally{l&&l.length>0&&l.fill(0),a&&a.length>0&&a.fill(0)}}const O=document.getElementById("passwordForm"),f=document.getElementById("generateBtn"),w=document.getElementById("passwordDisplay"),I=document.getElementById("generatedPassword"),y=document.getElementById("copyBtn"),m=document.getElementById("errorMessage");O.addEventListener("submit",async t=>{t.preventDefault();const r=document.getElementById("site").value.trim(),o=document.getElementById("loginName").value.trim(),s=document.getElementById("masterPassword").value,e=parseInt(document.getElementById("pwdLength").value),n=parseInt(document.getElementById("counter").value),c=document.querySelectorAll('input[name="charset"]:checked'),a=Array.from(c).map(i=>i.value);if(a.length===0){g("请至少选择一种字符类型");return}const l=document.getElementById("symbolType").value,u={characterSets:a,symbolType:l};f.disabled=!0,f.textContent="生成中...",m.style.display="none";try{const i=await N(r,o,s,e,n,u);P(i)}catch(i){g(i instanceof Error?i.message:"生成失败")}finally{f.disabled=!1,f.textContent="生成密码"}});function P(t){I.textContent=t,w.style.display="block",w.scrollIntoView({behavior:"smooth"})}function g(t){m.textContent=t,m.style.display="block"}y.addEventListener("click",async()=>{const t=I.textContent;if(t)try{await navigator.clipboard.writeText(t),y.textContent="已复制",setTimeout(()=>{y.textContent="复制"},2e3)}catch{g("复制失败，请手动复制")}});
